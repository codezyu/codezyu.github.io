<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="keywords" content="Hexo Theme Redefine"><meta name="author" content="zyu"><script>!function(){const e="dark";function t(t){const o=t===e,c=document.documentElement;c.setAttribute("data-theme",t),c.classList.add(t),c.classList.remove(o?"light":e),c.style.colorScheme=t}const o=function(){try{const t=localStorage.getItem("REDEFINE-THEME-STATUS");if(t){const{isDark:o}=JSON.parse(t);return o?e:"light"}}catch(e){}return matchMedia("(prefers-color-scheme: dark)").matches?e:"light"}();t(o),matchMedia("(prefers-color-scheme: dark)").addEventListener("change",({matches:o})=>{localStorage.getItem("REDEFINE-THEME-STATUS")||t(o?e:"light")}),"loading"!==document.readyState?document.body.classList.add(o+"-mode"):document.addEventListener("DOMContentLoaded",()=>{document.body.classList.add(o+"-mode"),document.body.classList.remove((o===e?"light":e)+"-mode")})}()</script><style>:root[data-theme=dark]{--background-color:#202124;--background-color-transparent:rgba(32, 33, 36, 0.6);--second-background-color:#2d2e32;--third-background-color:#34353a;--third-background-color-transparent:rgba(32, 33, 36, 0.6);--primary-color:#0066CC;--first-text-color:#ffffff;--second-text-color:#eeeeee;--third-text-color:#bebec6;--fourth-text-color:#999999;--default-text-color:#bebec6;--invert-text-color:#373D3F;--border-color:rgba(255, 255, 255, 0.08);--selection-color:#0066CC;--shadow-color-1:rgba(255, 255, 255, 0.08);--shadow-color-2:rgba(255, 255, 255, 0.05)}:root[data-theme=light]{--background-color:#fff;--background-color-transparent:rgba(255, 255, 255, 0.6);--second-background-color:#f8f8f8;--third-background-color:#f2f2f2;--third-background-color-transparent:rgba(241, 241, 241, 0.6);--primary-color:#0066CC;--first-text-color:#16171a;--second-text-color:#2f3037;--third-text-color:#5e5e5e;--fourth-text-color:#eeeeee;--default-text-color:#373D3F;--invert-text-color:#bebec6;--border-color:rgba(0, 0, 0, 0.08);--selection-color:#0066CC;--shadow-color-1:rgba(0, 0, 0, 0.08);--shadow-color-2:rgba(0, 0, 0, 0.05)}body{background-color:var(--background-color);color:var(--default-text-color)}:root[data-theme=dark] body{background-color:var(--background-color);color:var(--default-text-color)}</style><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="canonical" href="http://example.com/2025/01/30/arch/net/rdma tech report/"><meta name="robots" content="index,follow"><meta name="googlebot" content="index,follow"><meta name="revisit-after" content="1 days"><meta name="description" content="Journey."><meta property="og:type" content="article"><meta property="og:title" content="RDMA概览"><meta property="og:url" content="http://example.com/2025/01/30/Arch/Net/RDMA%20Tech%20Report/index.html"><meta property="og:site_name" content="Hexo"><meta property="og:description" content="Journey."><meta property="og:locale" content="en_US"><meta property="og:image" content="http://example.com/images/redefine-og.webp"><meta property="article:published_time" content="2025-01-30T00:00:00.000Z"><meta property="article:modified_time" content="2025-10-12T17:00:10.568Z"><meta property="article:author" content="John Doe"><meta property="article:tag" content="Tech"><meta property="article:tag" content="achitechture"><meta property="article:tag" content="RDMA"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="http://example.com/images/redefine-og.webp"><link rel="icon" type="image/png" href="/images/website/icon.png" sizes="192x192"><link rel="apple-touch-icon" sizes="180x180" href="/images/website/icon.png"><meta name="theme-color" content="#BACCD9"><link rel="shortcut icon" href="/images/website/icon.png"><title>RDMA概览 | zyu&#39;s blog</title><link rel="stylesheet" href="/fonts/Chillax/chillax.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/build/tailwind.css"><link rel="stylesheet" href="/fonts/GeistMono/geist-mono.css"><link rel="stylesheet" href="/fonts/Geist/geist.css"><link href="" rel="stylesheet"><script id="hexo-configurations">window.config={hostname:"example.com",root:"/",language:"en"},window.theme={articles:{style:{font_size:"16px",line_height:1.5,image_border_radius:"14px",image_alignment:"center",image_caption:!1,link_icon:!0,delete_mask:!1,title_alignment:"left",headings_top_spacing:{h1:"3.2rem",h2:"2.4rem",h3:"1.9rem",h4:"1.6rem",h5:"1.4rem",h6:"1.3rem"}},word_count:{enable:!0,count:!0,min2read:!0},author_label:{enable:!0,auto:!1,list:[]},code_block:{copy:!0,style:"mac",highlight_theme:{light:"github",dark:"vs2015"},font:{enable:!1,family:null,url:null}},toc:{enable:!0,max_depth:3,number:!1,expand:!0,init_open:!0},copyright:{enable:!0,default:"cc_by_nc_sa"},lazyload:!0,pangu_js:!1,recommendation:{enable:!1,title:"推荐阅读",limit:3,mobile_limit:2,placeholder:"/images/wallhaven-wqery6-light.webp",skip_dirs:[]}},colors:{primary:"#BACCD9",secondary:null,default_mode:"light"},global:{fonts:{chinese:{enable:!0,family:null,url:null},english:{enable:!1,family:null,url:null},title:{enable:!1,family:null,url:null}},content_max_width:"1000px",sidebar_width:"210px",hover:{shadow:!0,scale:!1},scroll_progress:{bar:!1,percentage:!0},website_counter:{url:"https://cn.vercount.one/js",enable:!0,site_pv:!0,site_uv:!0,post_pv:!0},single_page:!0,preloader:{enable:!1,custom_message:null},side_tools:{gear_rotation:!0,auto_expand:!1},open_graph:{enable:!0,image:"/images/redefine-og.webp",description:"Journey."},google_analytics:{enable:!1,id:null}},home_banner:{enable:!1,style:"fixed",image:{light:"/images/wallhaven-wqery6-light.webp",dark:"/images/wallhaven-wqery6-dark.webp"},title:"sleep time",subtitle:{text:[],hitokoto:{enable:!1,show_author:!1,api:"https://v1.hitokoto.cn"},typing_speed:100,backing_speed:80,starting_delay:500,backing_delay:1500,loop:!0,smart_backspace:!0},text_color:{light:"#fff",dark:"#d1d1b6"},text_style:{title_size:"2.8rem",subtitle_size:"1.5rem",line_height:1.2},custom_font:{enable:!1,family:null,url:null},social_links:{enable:!1,style:"default",links:{github:null,instagram:null,zhihu:null,twitter:null,email:null},qrs:{weixin:null}}},plugins:{feed:{enable:!0},aplayer:{enable:!0,type:"fixed",audios:[{name:null,artist:null,url:null,cover:null,lrc:null}]},mermaid:{enable:!0,version:"11.4.1"}},version:"2.8.5",navbar:{auto_hide:!1,color:{left:"#f78736",right:"#367df7",transparency:35},width:{home:"1200px",pages:"1000px"},links:{Home:{path:"/",icon:"fa-regular fa-house"},Archives:{path:"/archives",icon:"fa-regular fa-archive"}},search:{enable:!0,preload:!0}},page_templates:{friends_column:2,tags_style:"blur"},home:{sidebar:{enable:!0,position:"left",first_item:"menu",announcement:null,show_on_mobile:!0,links:null},article_date_format:"auto",excerpt_length:200,categories:{enable:!0,limit:3},tags:{enable:!0,limit:3}},footerStart:"2022/8/17 11:45:14"},window.lang_ago={second:"%s seconds ago",minute:"%s minutes ago",hour:"%s hours ago",day:"%s days ago",week:"%s weeks ago",month:"%s months ago",year:"%s years ago"},window.data={masonry:!1}</script><link rel="stylesheet" href="/fontawesome/fontawesome.min.css"><link rel="stylesheet" href="/fontawesome/brands.min.css"><link rel="stylesheet" href="/fontawesome/solid.min.css"><link rel="stylesheet" href="/fontawesome/regular.min.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div class="progress-bar-container"><span class="pjax-progress-bar"></span></div><main class="page-container" id="swup"><div class="main-content-container flex flex-col justify-between min-h-dvh"><div class="main-content-header"><header class="navbar-container px-6 md:px-12"><div class="navbar-content transition-navbar"><div class="left"><a class="logo-image h-8 w-8 sm:w-10 sm:h-10 mr-3" href="/"><img src="/images/website/logo.jpg" class="w-full h-full rounded-xs"> </a><a class="logo-title" href="/">zyu&#39;s blog</a></div><div class="right"><div class="desktop"><ul class="navbar-list"><li class="navbar-item"><a href="/"><i class="fa-regular fa-house fa-fw"></i> HOME</a></li><li class="navbar-item"><a href="/archives"><i class="fa-regular fa-archive fa-fw"></i> ARCHIVES</a></li><li class="navbar-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i></li></ul></div><div class="mobile"><div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i></div><div class="icon-item navbar-bar"><div class="navbar-bar-middle"></div></div></div></div></div><div class="navbar-drawer h-dvh w-full absolute top-0 left-0 bg-background-color flex flex-col justify-between"><ul class="drawer-navbar-list flex flex-col px-4 justify-center items-start"><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" href="/"><span>HOME </span><i class="fa-regular fa-house fa-sm fa-fw"></i></a></li><li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full"><a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full" href="/archives"><span>ARCHIVES </span><i class="fa-regular fa-archive fa-sm fa-fw"></i></a></li></ul><div class="statistics flex justify-around my-2.5"><a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/tags"><div class="number text-2xl sm:text-xl text-second-text-color font-semibold">11</div><div class="label text-third-text-color text-sm">Tags</div></a><a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/categories"><div class="number text-2xl sm:text-xl text-second-text-color font-semibold">0</div><div class="label text-third-text-color text-sm">Categories</div></a><a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/archives"><div class="number text-2xl sm:text-xl text-second-text-color font-semibold">7</div><div class="label text-third-text-color text-sm">Posts</div></a></div></div><div class="window-mask"></div></header></div><div class="main-content-body transition-fade-up"><div class="main-content"><div class="post-page-container flex relative justify-between box-border w-full h-full"><div class="article-content-container"><div class="article-title relative w-full"><div class="w-full flex items-center pt-6 justify-start"><h1 class="article-title-regular text-second-text-color tracking-tight text-4xl md:text-6xl font-semibold px-2 sm:px-6 md:px-8 py-3">RDMA概览</h1></div></div><div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8"><div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]"><img src="/images/website/racket.png"></div><div class="info flex flex-col justify-between"><div class="author flex items-center"><span class="name text-default-text-color text-lg font-semibold">zyu</span> <span class="author-label ml-1.5 text-xs px-2 py-0.5 rounded-small text-third-text-color border border-shadow-color-1">Lv1</span></div><div class="meta-info"><div class="article-meta-info"><span class="article-date article-meta-item"><i class="fa-regular fa-pen-fancy"></i>&nbsp; <span class="desktop">2025-01-30</span> <span class="mobile">2025-01-30</span> <span class="hover-info">Created</span> </span><span class="article-date article-meta-item"><i class="fa-regular fa-wrench"></i>&nbsp; <span class="desktop">2025-10-12 17:10</span> <span class="mobile">2025-10-12 17:10</span> <span class="hover-info">Updated</span> </span><span class="article-tags article-meta-item"><i class="fa-regular fa-tags"></i>&nbsp;<ul><li><a href="/tags/Tech/">Tech</a>&nbsp;</li><li>| <a href="/tags/achitechture/">achitechture</a>&nbsp;</li><li>| <a href="/tags/RDMA/">RDMA</a>&nbsp;</li></ul></span><span class="article-pv article-meta-item"><i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span></span></div></div></div></div><div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8"><h1 id="RDMA介绍"><a href="#RDMA介绍" class="headerlink" title="RDMA介绍"></a>RDMA介绍</h1><p>RDMA(Remote Direct Memory Access)通过网卡(RDMA NIC简称RNIC)将网络请求转换为DMA请求，进而直接实现内存读写。RDMA相当把操作卸载到RNIC，实现了bypass 内核。<br><img lazyload src="/images/loading.svg" data-src="https://cloudflare-imgbed-4ea.pages.dev/file/Arch/RDMA/1760286499272_RDMA_and_Socket.png" alt="650"></p><p>如上图所示，RDMA的协议有Infiniband, ROCE, iWarp。Infiniband(IB)是Mallenox提供的企业方案，性能稳定，缺陷是需要单独的物理设备比如交换机和网卡，定制权掌握在Mallenox里面，修改空间小，并且scale out的能力有限，一般只能在集群内，数量最大到千台设备左右。iWARP事实上可能被放弃了。ROCE基于以太网现有设备，覆盖范围广，可以用于跨集群的RDMA连接，修改空间大，是企业使用RDMA的首选方案，缺陷是在配置使用有许多隐藏的问题，需要企业自行解决。<br>在RDMA通信的两边为HCA(host channel adpaters)<br>对RNIC的控制请求为WR(work request)，用于说明RDMA的网络传输所需数据内容，以及相关操作等等。<br>为了向RNIC发送指令，需要借助RDMA Verbs。在RDMA Verbs中包括Memory Verbs和Message Verbs。<br>消息组织的方式为消息队列(Queue Pair, QP)，QP包含一对队列WQ(Work Queue)和CQ(Completion Queue)。其中Work Queue实例包含Send Queue(SQ, 用于放入发送方的WR)，Receive Queue(RQ, 接收方的WR，用于说明消息放在哪里)。同时提供了消息完成的通知机制 Completion Queue(CQ)，WR完成后的completion通知以CQE(Completion Queue Entry)的方式放入CQ<br><img lazyload src="/images/loading.svg" data-src="https://cloudflare-imgbed-4ea.pages.dev/file/Arch/RDMA/1760286538870_RDMA_WQ_and_CQ.png" alt="500"><br>当RDMA的消息来到远端的RNIC后，RNIC需要将其转换为内存访问即DMA</p><h1 id="RDMA软件栈"><a href="#RDMA软件栈" class="headerlink" title="RDMA软件栈"></a>RDMA软件栈</h1><p>虽然RDMA在数据传输过程中，绕过了内核。但是比如连接建立过程中仍然需要进入内核态管理关键资源。以Infiniband为例，用户态和内核态软件架构为（下面都以ibverbs为例）当然ibverbs实际上也适合ROCE</p><h2 id="内核模块"><a href="#内核模块" class="headerlink" title="内核模块"></a>内核模块</h2><ul><li>mlx5_core 以太网设备驱动</li><li>mlx5_ib ib 设备驱动</li><li>ib_uverbs 用户态驱动  (entry point for <code>libibverbs</code>)</li></ul><h2 id="用户模块"><a href="#用户模块" class="headerlink" title="用户模块"></a>用户模块</h2><p>RDMA自上而下的软件架构可以分为：</p><ul><li>verbs接口： libibverbs 提供了通用RDMA接口，提供低速和权限操作 比如资源管理 包含了两个版本 RDMA-core 和Mellanox设备的库。虽然同名但是Mellanox提供了实验特性，主要的API在<code>verbs-exp.h</code>。在5.1.6之后Mellanox进入主线，放弃实验特性。</li><li>硬件驱动：提供了与MLX5设备相关的操作，而libmlx5则作为libibverbs底层库<br><img lazyload src="/images/loading.svg" data-src="https://cloudflare-imgbed-4ea.pages.dev/file/Arch/RDMA/1760286719250_hyperloop_sturcture_in_IB.png" alt="hyperloop_sturcture_in_IB.png"></li></ul><h2 id="libibverbs"><a href="#libibverbs" class="headerlink" title="libibverbs"></a>libibverbs</h2><p>同样可以用于ROCE, 对用户隐藏了硬件细节</p><h2 id="libmlx5"><a href="#libmlx5" class="headerlink" title="libmlx5"></a>libmlx5</h2><p>在旧的RNIC上，对应的用户库可能为libmlx4。<br>这个用户态的驱动可以使用内核模块，也可以直接控制设备。使用内核模块时，主要用于register objects比如(queue pairs, memory regions, etc)，也可以获得网卡Doorbell register映射到内存区域的地址。<br>因此libmlx5可以直接在用户态ring the doorbell而无需context切换。</p><h1 id="RDMA通信简易流程"><a href="#RDMA通信简易流程" class="headerlink" title="RDMA通信简易流程"></a>RDMA通信简易流程</h1><h2 id="device-context"><a href="#device-context" class="headerlink" title="device context"></a>device context</h2><ol><li>先获取device context，用于提供硬件信息<br>先获取设备列表</li></ol><div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ibv_device</span> **<span class="built_in">ibv_get_device_list</span>(<span class="type">int</span> *num_devices);</span><br></pre></td></tr></table></figure></div><p>会同时返回设备的指针列表和设备数量<br>在设备列表里面选择可用的设备，以IB设备为例，一般会提供两个网口<code>mlx5_0</code>和<code>mlx5_1</code></p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ibstat</span><br></pre></td></tr></table></figure></div><p>输出为</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CA &#x27;mlx5_1&#x27;</span><br><span class="line">        CA type: MT41692</span><br><span class="line">	    ...</span><br><span class="line">        Port 1:</span><br><span class="line">                State: Active</span><br><span class="line">                Physical state: LinkUp</span><br><span class="line">                ...</span><br><span class="line">                Link layer: InfiniBand</span><br></pre></td></tr></table></figure></div><p>比如通过其状态可知我们需要选择的设备为<code>mlx5_1</code>，再到设备列表里面进行筛选所需设备</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ibv_get_device_name(deviceList[i])[5]==&quot;1&quot; //原函数输出为&quot;mlx5_1&quot;</span><br></pre></td></tr></table></figure></div><p>然后打开设备的context</p><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ibv_context *<span class="title function_">ibv_open_device</span><span class="params">(<span class="keyword">struct</span> ibv_device *device)</span>;</span><br></pre></td></tr></table></figure></div><ol start="2"><li>接着是获取端口信息, 端口号如上面的输出可知为1，端口信息能够提供比如有<code>lid</code>等，用于后续的寻址</li></ol><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ibv_query_port</span><span class="params">(<span class="keyword">struct</span> ibv_context *context, <span class="type">uint8_t</span> port_num,<span class="keyword">struct</span> _compat_ibv_port_attr *port_attr)</span>;</span><br></pre></td></tr></table></figure></div><ol start="3"><li>获取pd,pd可用于后面的内存管理</li></ol><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ibv_pd *<span class="title function_">ibv_alloc_pd</span><span class="params">(<span class="keyword">struct</span> ibv_context *context)</span>;</span><br></pre></td></tr></table></figure></div><ol start="4"><li>获取gid信息，这部分取决于RDMA网络的连接情况，如果没有配置IB交换机则不需要此部分。gid用于寻址</li></ol><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ibv_query_gid</span><span class="params">(<span class="keyword">struct</span> ibv_context *context, <span class="type">uint8_t</span> port_num, <span class="type">int</span> index, <span class="keyword">union</span> ibv_gid *gid)</span>;</span><br></pre></td></tr></table></figure></div><h2 id="注册内存"><a href="#注册内存" class="headerlink" title="注册内存"></a>注册内存</h2><p>用于RDMA之间的内存传输，具体可见内存管理部分</p><ol><li>内存分配一块区域</li><li>通过PD注册内存</li></ol><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ibv_mr *<span class="title function_">ibv_reg_mr</span><span class="params">(<span class="keyword">struct</span> ibv_pd *pd, <span class="type">void</span> *addr, <span class="type">size_t</span> length,</span></span><br><span class="line"><span class="params">              <span class="type">int</span> access)</span>;</span><br></pre></td></tr></table></figure></div><h2 id="QP"><a href="#QP" class="headerlink" title="QP"></a>QP</h2><p>接下来是创建QP队列，QP队列是一种通信模型(RQ+SQ)，需要CQ，可以设定创建SRQ,即Send和Recv共用一个队列来节省空间</p><ol><li>先创建CQ</li></ol><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ibv_cq *<span class="title function_">ibv_create_cq</span><span class="params">(<span class="keyword">struct</span> ibv_context *context, <span class="type">int</span> cqe,</span></span><br><span class="line"><span class="params">                 <span class="type">void</span> *cq_context,</span></span><br><span class="line"><span class="params">                 <span class="keyword">struct</span> ibv_comp_channel *channel,</span></span><br><span class="line"><span class="params">                 <span class="type">int</span> comp_vector)</span>;</span><br></pre></td></tr></table></figure></div><ol start="2"><li>创建QP，需要指定PD，因为QP在保护域内</li></ol><div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ibv_qp</span> *<span class="built_in">ibv_create_qp</span>(<span class="keyword">struct</span> ibv_pd *pd,</span><br><span class="line">                 <span class="keyword">struct</span> ibv_qp_init_attr *qp_init_attr);</span><br></pre></td></tr></table></figure></div><p>在QP的属性<code>ibv_qp_init_attr</code> 中可以指定</p><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ibv_cq</span>          *<span class="title">send_cq</span>;</span> <span class="comment">//指定send的CQ</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ibv_cq</span>          *<span class="title">recv_cq</span>;</span> <span class="comment">//Recv的CQ</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ibv_srq</span>         *<span class="title">srq</span>;</span>     <span class="comment">// SQR</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ibv_qp_cap</span>   <span class="title">cap</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">ibv_qp_type</span>    <span class="title">qp_type</span>;</span>     <span class="comment">//定义通信模型 比如RC UD</span></span><br></pre></td></tr></table></figure></div><h2 id="信息交换"><a href="#信息交换" class="headerlink" title="信息交换"></a>信息交换</h2><p>在QP创建完成后，根据不同的通信模型，支持的RDMA操作类型也不同，交换的信息包括<br>具体解释见QP信息交换</p><h2 id="QP队列状态切换"><a href="#QP队列状态切换" class="headerlink" title="QP队列状态切换"></a>QP队列状态切换</h2><p>见后面的QP状态机</p><h2 id="RDMA操作"><a href="#RDMA操作" class="headerlink" title="RDMA操作"></a>RDMA操作</h2><p>后面的RDMA操作部分</p><h1 id="RDMA服务类型"><a href="#RDMA服务类型" class="headerlink" title="RDMA服务类型"></a>RDMA服务类型</h1><h2 id="QP队列"><a href="#QP队列" class="headerlink" title="QP队列"></a>QP队列</h2><p>RDMA的通信双端为QP队列，QP是软件和硬件之间的虚拟接口<br>一个节点可以有多个QP队列，每个QP都有一个唯一的编号为QPN，每个QP队列可以关联一个远端的QP队列。值得注意的QPN是每个节点独立维护的序号，但是不是网络唯一的，不同的节点的QPN可能相同。<br>IB协议中规定用24个bit来表示QPN, 其中有两个特殊保留编号</p><ul><li>QP0<br>编号为0的QP用于子网管理接口SMI（Subnet Management Interface），用于管理子网中的全部节点<br>如果发送成功，也会显示来自QP0队列</li><li>QP1<br>编号为1的QP用于通用服务接口GSI（General Service Interface）</li></ul><h3 id="SQ和RQ"><a href="#SQ和RQ" class="headerlink" title="SQ和RQ"></a>SQ和RQ</h3><h3 id="CQ"><a href="#CQ" class="headerlink" title="CQ"></a>CQ</h3><p>CQ和SQ以及RQ不同的是，CQ是由网卡处理完WR之后，由网卡生成WRs并且放入CQ中。因此如果想要知道是否完成，需要不断地polling CQ。当然也提供evnet based blocking method[1]<br>在wc中</p><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ibv_wc</span> &#123;</span></span><br><span class="line">	<span class="type">uint64_t</span>		wr_id;<span class="comment">//可以用于指示具体接收到哪个请求 poll到的时候可以查看</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">ibv_wc_status</span>	<span class="title">status</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">ibv_wc_opcode</span>	<span class="title">opcode</span>;</span></span><br><span class="line">	<span class="type">uint32_t</span>		vendor_err;</span><br><span class="line">	<span class="type">uint32_t</span>		byte_len;</span><br><span class="line">	<span class="comment">/* When (wc_flags &amp; IBV_WC_WITH_IMM): Immediate data in network byte order.</span></span><br><span class="line"><span class="comment">	 * When (wc_flags &amp; IBV_WC_WITH_INV): Stores the invalidated rkey.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		__be32		imm_data;</span><br><span class="line">		<span class="type">uint32_t</span>	invalidated_rkey;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="type">uint32_t</span>		qp_num;<span class="comment">//wc关联的哪个qp</span></span><br><span class="line">	<span class="type">uint32_t</span>		src_qp;<span class="comment">//发送端的qp</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		wc_flags;</span><br><span class="line">	<span class="type">uint16_t</span>		pkey_index;</span><br><span class="line">	<span class="type">uint16_t</span>		slid;</span><br><span class="line">	<span class="type">uint8_t</span>			sl;</span><br><span class="line">	<span class="type">uint8_t</span>			dlid_path_bits;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><h3 id="SRQ"><a href="#SRQ" class="headerlink" title="SRQ"></a>SRQ</h3><p>基于QP上面的通信模型，按照可靠和连接提供不同程度的保障</p><h2 id="可靠"><a href="#可靠" class="headerlink" title="可靠"></a>可靠</h2><p>数据在发送者和接收者之间信息只会传递一次，并且按顺序被接收<br>不会有的情况：乱序，重复数据</p><h3 id="实现原理："><a href="#实现原理：" class="headerlink" title="实现原理："></a>实现原理：</h3><ul><li>应答机制：每个包都要有ACK，当然可以一次回复多个包</li><li>数据校验：如果校验，丢弃对应的包</li><li>保序：每个包有递增的编号，如果提前到达则回复重发</li></ul><h3 id="PSN"><a href="#PSN" class="headerlink" title="PSN"></a>PSN</h3><p>Packet Sequence Number,用于校验包的顺序和是否丢失，可以在修改QP队列状态属性(to RTS)时填入</p><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">attr.sq_psn = PSN;</span><br></pre></td></tr></table></figure></div><h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><p>建立一条通信管道，类似sokcet，一端发送的数据一定会到另一端。面向连接的QP会交换对端的信息，并将记录在QP Context里面，在QP的WQE可以直接到绑定连接的另一端QP。<br><strong>数据报datagram</strong><br>和连接的逻辑相反，QP之间不会绑定 每个WQE可能可能指向不同的目的地。但是仍然需要建立通信交换对端QP信息</p><table><thead><tr><th></th><th>可靠(reliable)</th><th>不可靠(unreliable)</th></tr></thead><tbody><tr><td>连接(connection)</td><td>RC(reliable connection)</td><td>UC(unreliable connection)</td></tr><tr><td>数据报(datagram)</td><td>RD(reliable Datagram)</td><td>UD(unreliable datagram)</td></tr><tr><td>RC和UD是应用最多也是最基础的两种服务类型，我们可以将他们分别类比成TCP&#x2F;IP协议栈传输层的TCP和UDP。</td><td></td><td></td></tr><tr><td>RD目前不被IB支持[2]</td><td></td><td></td></tr></tbody></table><h2 id="支持操作"><a href="#支持操作" class="headerlink" title="支持操作"></a>支持操作</h2><p>在RDMA操作中，根据底层的通信模型，支持的操作为[3]</p><table><thead><tr><th></th><th>Send&#x2F;Recv</th><th>write&#x2F;imm</th><th>read&#x2F;atomic</th><th>MTU</th></tr></thead><tbody><tr><td>RC</td><td>√</td><td>√</td><td>√</td><td>2GB</td></tr><tr><td>UC</td><td>√</td><td>√</td><td>×</td><td>2GB</td></tr><tr><td>UD</td><td>√</td><td>×</td><td>×</td><td>4KB</td></tr></tbody></table><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li>CQ由硬件生成<br><a class="link" target="_blank" rel="noopener" href="https://insujang.github.io/assets/pdf/hyperloop_report.pdf">https://insujang.github.io/assets/pdf/hyperloop_report.pdf<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li><li>RDMA Aware Networks Programming User Manual<br><a class="link" target="_blank" rel="noopener" href="https://docs.nvidia.com/rdma-aware-networks-programming-user-manual-1-7.pdf">https://docs.nvidia.com/rdma-aware-networks-programming-user-manual-1-7.pdf<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li><li>Scalable RDMA RPC on Reliable Connection with Efficient Resource Sharing<br><a class="link" target="_blank" rel="noopener" href="https://dl.acm.org/doi/pdf/10.1145/3302424.3303968">https://dl.acm.org/doi/pdf/10.1145/3302424.3303968<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li></ol><h1 id="RDMA协议"><a href="#RDMA协议" class="headerlink" title="RDMA协议"></a>RDMA协议</h1><p>RDMA协议用于说明具体的实现细节，前面可知分为三种</p><ul><li>IB 需要IB网卡和IB交换机</li><li>RoCE 需要特殊网卡</li><li>iWARP 可以用软件支持，但是没有offload CPU的优势，因此也需要特殊网卡</li></ul><h2 id="RDMA网络结构"><a href="#RDMA网络结构" class="headerlink" title="RDMA网络结构"></a>RDMA网络结构</h2><p>采用两层结构</p><ul><li>第一层： 跨子网 通过GID寻址</li><li>第二层： 子网 其中lid是IB协议栈的二层属性，在ROCE中是不用的</li></ul><h3 id="ROCE"><a href="#ROCE" class="headerlink" title="ROCE"></a>ROCE</h3><p>配置GRH</p><h3 id="iWARP"><a href="#iWARP" class="headerlink" title="iWARP"></a>iWARP</h3><p>应该仅使用通用 RDMA CM 代理 (CMA) 连接 QP</p><h2 id="寻址"><a href="#寻址" class="headerlink" title="寻址"></a>寻址</h2><h3 id="GID"><a href="#GID" class="headerlink" title="GID"></a>GID</h3><p>由于QPN不唯一，为了寻址，IB协议提供了GID(Global Identifier，全局ID) 用于标识设备端口的地址，主要用于 <strong>RoCE (RDMA over Converged Ethernet)</strong> 和 <strong>IB (InfiniBand)</strong> 网络的通信 全局唯一<br>为了能够获取gid</p><div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ibv_query_gid</span><span class="params">(<span class="keyword">struct</span> ibv_context *context, <span class="type">uint8_t</span> port_num, <span class="type">int</span> index, <span class="keyword">union</span> ibv_gid *gid)</span></span>;</span><br></pre></td></tr></table></figure></div><p>最后的gid (GID table entry)会赋给指针指向的地址<br>在index参数代表，在GID的索引<br><code>gid_index = 0</code> 是默认的 GID，表示基本的通信路径<br>使用中可以通过查看（和query_device效果一致）</p><div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ibv_devinfo</span><br></pre></td></tr></table></figure></div><p>输出为(这里并没有看到GID)</p><blockquote><p>该问题在connectx6以上能看到</p></blockquote><div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">hca_id: mlx5_1</span><br><span class="line">        transport:                      InfiniBand (0)</span><br><span class="line">		...</span><br><span class="line">        phys_port_cnt:                  1 #port代表物理端口</span><br><span class="line">                port:   1</span><br><span class="line">                        state:                  PORT_ACTIVE (4)</span><br><span class="line">                        max_mtu:                4096 (5)</span><br><span class="line">                        active_mtu:             4096 (5) #这里和QP队列的设置相关</span><br><span class="line">                        sm_lid:                 1</span><br><span class="line">                        port_lid:               9 #lid是下面需要的</span><br><span class="line">                        port_lmc:               0x00</span><br><span class="line">                        link_layer:             InfiniBand</span><br></pre></td></tr></table></figure></div><p>可以通过查看</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show_gids</span><br></pre></td></tr></table></figure></div><p>输出为</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DEV     PORT    INDEX   GID                                     IPv4            VER     DEV</span><br><span class="line">---     ----    -----   ---                                     ------------    ---     ---</span><br><span class="line">mlx5_0  1       0       fe80:0000:0000:0000:a088:c203:0031:ed08                 v1</span><br><span class="line">mlx5_1  1       0       fe80:0000:0000:0000:a088:c203:0031:ed09                 v1</span><br><span class="line">n_gids_found=2</span><br></pre></td></tr></table></figure></div><p>或者是</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ibstatus</span><br></pre></td></tr></table></figure></div><p>同时RDMA在子网中需要找到端口，LID(local ID)，通过在创建RDMA context时候查询并需要交换给对端的信息</p><div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//port num为IB口 mlx5_1此类 只需要传入1即可</span></span><br><span class="line"><span class="built_in">ibv_query_port</span>(context, port_num, &amp;port_attr)</span><br><span class="line"><span class="comment">//port_attr.lid</span></span><br></pre></td></tr></table></figure></div><h3 id="LID"><a href="#LID" class="headerlink" title="LID"></a>LID</h3><p>由subnet manager赋予节点</p><h3 id="address-handle"><a href="#address-handle" class="headerlink" title="address handle"></a>address handle</h3><p>AH是远端节点地址信息的集合。<br>在RC中，信息存储于QP context中（修改QP状态为RTR时传入）<br>在UD中，QP没有绑定，因此在发送消息的时候，需要把地址信息AH传入。AH放置于特殊地址空间，需要进入内核态创建，同样在PD内</p><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ibv_ah *<span class="title function_">ibv_create_ah</span><span class="params">(<span class="keyword">struct</span> ibv_pd *pd, <span class="keyword">struct</span> ibv_ah_attr *attr)</span>;</span><br></pre></td></tr></table></figure></div><p>在<code>ibv_ah_attr</code>中，需要传入的信息主要包括</p><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ibv_ah_attr</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ibv_global_route</span> <span class="title">grh</span>;</span><span class="comment">//GID</span></span><br><span class="line">    <span class="type">uint16_t</span>        dlid;<span class="comment">//对端LID</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="type">uint8_t</span>         is_global;<span class="comment">//是否使用GID</span></span><br><span class="line">    <span class="type">uint8_t</span>         port_num;<span class="comment">//端口号</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><h2 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h2><h1 id="RDMA通信"><a href="#RDMA通信" class="headerlink" title="RDMA通信"></a>RDMA通信</h1><p>由于RDMA通信依赖双方的QP队列，需要交换信息</p><h2 id="QP状态机"><a href="#QP状态机" class="headerlink" title="QP状态机"></a>QP状态机</h2><p>QP队列是通过状态机实现的<br><img lazyload src="/images/loading.svg" data-src="https://cloudflare-imgbed-4ea.pages.dev/file/Arch/RDMA/1760286808098_IB_QP%E9%98%9F%E5%88%97%E7%8A%B6%E6%80%81%E6%9C%BA.png" alt="IB_QP队列状态机.png"></p><p>绿色状态需要用户配置，红色状态为自动跳转</p><ul><li>RESET 已经创建，未配置 其无法接收用户下发的WQE，也无法接受对端某个QP的消息。</li><li>INIT 初始化 这个状态下，用户可以通过Post Receive给这个QP下发Receive WR，但是接收到的消息并不会被处理，会被静默丢弃；如果用户下发了一个Post Send的WR，则会报错。</li><li>RTR ready to Receive 准备接收 RQ可以正常工作，即对于接收到的消息，可以按照其中WQE的指示搬移数据到指定内存位置。此状态下SQ仍然不能工作。</li><li>RTS ready to Send 准备发送 从状态图可知，需要经历前面状态的转换 ，SQ可以正常工作，即用户可以进行Post Send，并且硬件也会根据SQ的内容将数据发送出去。进入该状态前，QP必须已于对端建立好链接。</li><li>错误状态： 处理过程中发生错误<br>根据通信模型 QP队列则必须设定为对应的状态才能进行通信<br>状态切换使用统一API，通过attr修改属性，mask说明修改了哪些属性项</li></ul><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ibv_modify_qp</span><span class="params">(<span class="keyword">struct</span> ibv_qp *qp, <span class="keyword">struct</span> ibv_qp_attr *attr,</span></span><br><span class="line"><span class="params">          <span class="type">int</span> attr_mask)</span>;</span><br></pre></td></tr></table></figure></div><h3 id="INIT"><a href="#INIT" class="headerlink" title="INIT"></a>INIT</h3><p><strong>连接(C)</strong></p><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.qp_state = IBV_QPS_INIT</span><br><span class="line">.port_num = port <span class="comment">//之前查询到的端口</span></span><br><span class="line">.qp_access_flags = IBV_ACCESS_REMOTE_WRITE<span class="comment">//根据通信模型的支持操作确定</span></span><br></pre></td></tr></table></figure></div><p><strong>数据报(D)</strong><br>该模式下需要额外添加QKey</p><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.qp_state = IBV_QPS_INIT;</span><br><span class="line">.pkey_index = <span class="number">0</span>;       <span class="comment">// 分区键索引，默认为 0</span></span><br><span class="line">.port_num = <span class="number">1</span>;         <span class="comment">// RDMA 设备端口号</span></span><br><span class="line">.qkey = <span class="number">0x11111111</span>;    <span class="comment">// UD 模式的 QKey 对应的mask为 IBV_QP_QKEY</span></span><br></pre></td></tr></table></figure></div><h3 id="RTR"><a href="#RTR" class="headerlink" title="RTR"></a>RTR</h3><p><strong>连接(C)</strong><br>RTR状态需要远端的信息<strong>LID</strong>和远端QPN，通过交换得到，因此该状态可以接收信息</p><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">.qp_state = IBV_QPS_RTR</span><br><span class="line">.path_mtu = IBV_MTU_4096 <span class="comment">//一般查询可知</span></span><br><span class="line">.dest_qp_num = qp_num <span class="comment">//远端的QP队列号</span></span><br><span class="line">.ibv_ah_attr &#123;</span><br><span class="line">    <span class="keyword">struct</span> ibv_global_route grh&#123;</span><br><span class="line">		<span class="keyword">union</span> ibv_gid      dgid&#123;</span><br><span class="line">			    <span class="type">uint8_t</span>         raw[<span class="number">16</span>];</span><br><span class="line">			    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			        __be64  subnet_prefix;</span><br><span class="line">			        __be64  interface_id;</span><br><span class="line">				&#125; global;</span><br><span class="line">		&#125;; <span class="comment">//gid 16B大小</span></span><br><span class="line">        <span class="type">uint32_t</span>        flow_label;</span><br><span class="line">	    <span class="type">uint8_t</span>         sgid_index;</span><br><span class="line">	    <span class="type">uint8_t</span>         hop_limit;</span><br><span class="line">	    <span class="type">uint8_t</span>         traffic_class;</span><br><span class="line">    &#125;<span class="comment">//在设置is_global = 1的时候生效 设置相关的网络操作</span></span><br><span class="line">    <span class="type">uint16_t</span>        dlid; <span class="comment">//设置远端的lid</span></span><br><span class="line">    <span class="type">uint8_t</span>         sl;</span><br><span class="line">    <span class="type">uint8_t</span>         src_path_bits;</span><br><span class="line">    <span class="type">uint8_t</span>         static_rate;</span><br><span class="line">    <span class="type">uint8_t</span>         is_global;</span><br><span class="line">    <span class="type">uint8_t</span>         port_num; <span class="comment">//设置本地端口</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><p><strong>数据报(D)</strong><br>该模式下只需要修改状态，<strong>其他的都不需要,修改了会报错</strong>,但是远端的<strong>LID</strong>和远端QPN信息需要在Send的时候使用</p><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qp_state = IBV_QPS_RTR;</span><br></pre></td></tr></table></figure></div><h3 id="RTS"><a href="#RTS" class="headerlink" title="RTS"></a>RTS</h3><p>主要是设置重试信息</p><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.qp_state=IBV_QPS_RTS,</span><br><span class="line">.timeout=<span class="number">14</span>,</span><br><span class="line">.retry_cnt=<span class="number">7</span>,</span><br><span class="line">.rnr_retry=<span class="number">7</span>,</span><br><span class="line">.sq_psn=<span class="number">0</span>,</span><br><span class="line">.max_rd_atomic=<span class="number">1</span></span><br></pre></td></tr></table></figure></div><h1 id="RDMA通信高级特性"><a href="#RDMA通信高级特性" class="headerlink" title="RDMA通信高级特性"></a>RDMA通信高级特性</h1><h2 id="RDMA-DCT"><a href="#RDMA-DCT" class="headerlink" title="RDMA DCT"></a>RDMA DCT</h2><p>dynamic connected transport 提供了RDMA动态连接机制</p><ul><li>允许在运行时动态地建立和拆除连接</li><li>使用了动态资源管理技术，能够动态回收资源<br>基于DC的通信类型，结合RC和UD的优点</li><li>支持RDMA和原子操作</li><li>scalable<br>原理是通过</li></ul><h3 id="key-object"><a href="#key-object" class="headerlink" title="key object"></a>key object</h3><ul><li>initiator: initiates data transfer 即发送端 DCI</li><li>target: Handles incoming data 接收数据 DCT<br>是特殊类型的QP，遵循基本的QP操作</li><li>post &#x2F; send &#x2F;receive</li></ul><h3 id="DCI"><a href="#DCI" class="headerlink" title="DCI"></a>DCI</h3><p>每个send-WR都携带了目的地址信息。如果DCI当前连接的对端不是send-WR里携带的对端，则它会首先断开当前的连接，再连接到send-WR里携带的对端。只要后续的send-WR里携带的都是当前已连接对端，则都可以复用当前已建立的连接。如果DCI在一段指定的时间内都没有发送操作则也会断开当前连接。注意DCT每次临时建立的是一个RC可靠连接。</p><p>DCI会有记录&lt; destination DCI&gt;的哈希表，新连接就可以走最老的DCI(LRU)。当池里DCI太少时，一个DCI会在不同的对端频繁切换，严重时建链报文数量会等同数据报文数量，这会大大恶化时延</p><h3 id="DCT"><a href="#DCT" class="headerlink" title="DCT"></a>DCT</h3><p><strong>DCT 连接池</strong><br>每个DCT有一个responders(DCRs)池，新进的DC连接会在这个池里分配一个DCR。当池资源不足时DCT会向发起新建连接的DCI回复connection NAK(CNAK)，同时丢弃来自这个DCI的后续报文。</p><p>在connectX-5只支持DCT v1，v0和v1版本之间不可互相操作</p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul><li>DCT 将packet翻倍了</li><li>同时相比RC mode 3us的延迟额外增加了100ns [2]</li></ul><h3 id="DCT-ODP特性"><a href="#DCT-ODP特性" class="headerlink" title="DCT ODP特性"></a>DCT ODP特性</h3><h2 id="QoS"><a href="#QoS" class="headerlink" title="QoS"></a>QoS</h2><p>RDMA支持通过QoS实现在不同packet的处理优先级，需要注册不同优先级的队列</p><h2 id="参考-2"><a href="#参考-2" class="headerlink" title="参考"></a>参考</h2><ol><li>openfabrics的PPT介绍<br><a class="link" target="_blank" rel="noopener" href="https://www.openfabrics.org/images/eventpresos/workshops2014/DevWorkshop/presos/Monday/pdf/05_DC_Verbs.pdf">https://www.openfabrics.org/images/eventpresos/workshops2014/DevWorkshop/presos/Monday/pdf/05_DC_Verbs.pdf<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li><li>DCT的早期测试<br>Designing MPI Library with Dynamic Connected Transport (DCT) of InfiniBand: Early Experiences: <a class="link" target="_blank" rel="noopener" href="https://link.springer.com/chapter/10.1007/978-3-319-07518-1_18">https://link.springer.com/chapter/10.1007/978-3-319-07518-1_18<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li></ol><h1 id="RDMA操作-1"><a href="#RDMA操作-1" class="headerlink" title="RDMA操作"></a>RDMA操作</h1><p>无论是何种通信，RDMA通信前都需要建立好QP，并且交换QP信息。由于此时RDMA还没建立连接，只能通过<code>out-of-band communication</code>比如（socket，第三方KV memecached等）提前交换信息。</p><h2 id="workflow"><a href="#workflow" class="headerlink" title="workflow"></a>workflow</h2><p>根据RDMA操作过程中控制面和数据面，可以分为</p><h3 id="control"><a href="#control" class="headerlink" title="control"></a>control</h3><ul><li>应用先创建资源，比如QP,CQ用于建立连接的资源</li><li>注册内存，映射关系发给RNIC<br>这些control verb由RDMA 用户库和driver 发送到command verb queue 触发doorbell 然后RNIC触发DMA</li></ul><h3 id="data"><a href="#data" class="headerlink" title="data"></a>data</h3><ul><li>应用把request放到SQ里面，通过用户库触发doorbell</li><li>RNIC DMA读取封装成packet</li></ul><h3 id="读写粒度"><a href="#读写粒度" class="headerlink" title="读写粒度"></a>读写粒度</h3><p>单边下 RDMA读写粒度为8B</p><blockquote><p>小于8B会操作失败</p></blockquote><h2 id="Host和RNIC的通信"><a href="#Host和RNIC的通信" class="headerlink" title="Host和RNIC的通信"></a>Host和RNIC的通信</h2><p>对于每次需要host cpu参与的RDMA通信<br>有两种方式</p><ol><li>CPU通过MMIO发出信息到NIC，信息包括要给NIC的WQE或者指向该WQE的地址信息<br>WQE通过64B的MMIOs (因为cacheline)发送 该方法延迟低，是默认的方法</li><li>CPU发送Doorbell请求给NIC ,NIC通过DMA去读取(batch)，能够减少MMIO传输次数和每次PCIe传输会添加头部数据，进而减少传输数据量[2]<br><img lazyload src="/images/loading.svg" data-src="https://cloudflare-imgbed-4ea.pages.dev/file/Arch/RDMA/1760286908713_RNIC-CPU_WQE.png" alt="RNIC-CPU_WQE.png"></li></ol><h2 id="QP信息交换"><a href="#QP信息交换" class="headerlink" title="QP信息交换"></a>QP信息交换</h2><h3 id="connenct-连接"><a href="#connenct-连接" class="headerlink" title="connenct(连接)"></a>connenct(连接)</h3><p>面向connect，需要交换的信息有</p><table><thead><tr><th>type</th><th>meaning</th></tr></thead><tbody><tr><td>QPN</td><td>QP队列序号，创建QP的时候生成</td></tr><tr><td>LID</td><td>local ID用于寻址标识</td></tr></tbody></table><h3 id="datagram"><a href="#datagram" class="headerlink" title="datagram"></a>datagram</h3><p>面向数据报，需要交换的信息有</p><table><thead><tr><th>type</th><th>meaning</th></tr></thead><tbody><tr><td>QPN</td><td>QP队列序号，创建QP的时候生成</td></tr><tr><td>LID</td><td>local ID用于寻址标识</td></tr><tr><td>QKey</td><td>用于校验包，发送的包需以远端的Qkey一致</td></tr></tbody></table><h2 id="双边通信"><a href="#双边通信" class="headerlink" title="双边通信"></a>双边通信</h2><p>双边通信无需额外交换信息<br>双边和单边的区别在于远端的CPU是否参与到通信中。而远端CPU的参与主要就是接收队列CQ。双边通信中SEND必须由RECV接收。<br>双边不需要额外交换信息</p><h2 id="RC-UC模式下"><a href="#RC-UC模式下" class="headerlink" title="RC&#x2F;UC模式下"></a>RC&#x2F;UC模式下</h2><p><img lazyload src="/images/loading.svg" data-src="https://cloudflare-imgbed-4ea.pages.dev/file/Arch/RDMA/1760286929940_hyperloop_RDMA_Send_Recv.png" alt="hyperloop_RDMA_Send_Recv.png"></p><h3 id="WR"><a href="#WR" class="headerlink" title="WR"></a>WR</h3><p>WR本质上是对RNIC的控制操作，用于告诉RNIC如何操纵数据。一个小结构体，包括指向buffer的指针，可以放在SQ和RQ</p><ul><li>在send queue，指针指向将要发送的message</li><li>在receive queue, 用来指示消息放在哪里<br>当work request完成后，网卡创建completion queue element（CQE）并放入CQ<br>WR只需要在用户态进行处理即可。其中WR 被分为Send WR和Recv WR, 创建完成后放入位于内存中的队列，由网卡拉取并处理。如图绿色部分<br><img lazyload src="/images/loading.svg" data-src="https://cloudflare-imgbed-4ea.pages.dev/file/Arch/RDMA/1760286953708_RDMA_two-sided_WQE.png" alt="RDMA_two-sided_WQE.png"><br>数据通过WQE指向的位置完成传输<br><img lazyload src="/images/loading.svg" data-src="https://cloudflare-imgbed-4ea.pages.dev/file/Arch/RDMA/1760286962835_RDMA_two-sided_%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93.png" alt="RDMA_two-sided_数据传输.png"><br>传输完成，创建一个CQE到完成队列中<br><img lazyload src="/images/loading.svg" data-src="https://cloudflare-imgbed-4ea.pages.dev/file/Arch/RDMA/1760286986846_RDMA_two-sided_CQ.png" alt="RDMA_two-sided_CQ.png"></li></ul><p>整体的通信过程如上图</p><ul><li>收发双端需要创建WR到队列中</li><li>发送端网卡从内存中拉取WR, 并且组装成RDMA数据包，发送到对端</li><li>对端接受后解析，并通过RQ队列的WR请求，写到对应的内存区域</li><li>完成后，创建CQE到完成队列中<br>可以看到，由于RQ的存在，实际上需要远端CPU参与通信的</li></ul><h3 id="接收WR"><a href="#接收WR" class="headerlink" title="接收WR"></a>接收WR</h3><p>由于DMA必须指定内存地址，事实上接收方要先比发送方在内存中准备接收队列CQ。否则就会触发RDMA协议中的错误机制，Recieve Not Ready (RNR)错误。<br>其中接收队列填入WR请求，如上图用于告诉网卡接收到的数据放置在哪。<br>当网卡接受到对端的RDMA数据包，解析后根据WQE决定数据写到内存何处。</p><div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ibv_recv_wr</span> &#123;</span><br><span class="line">    <span class="type">uint64_t</span>        wr_id;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ibv_recv_wr</span>     *next;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ibv_sge</span>         *sg_list;</span><br><span class="line">    <span class="type">int</span>         num_sge;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><h3 id="发起WR"><a href="#发起WR" class="headerlink" title="发起WR"></a>发起WR</h3><p>用户在发送端先装填好WR请求，放入内存中SQ队列中。<br>数据结构如下，其中<code>sge</code>类型以链表的方式进行连接, 里面每个sge包含要网卡需要读取的数据地址</p><div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ibv_send_wr</span> send_wr = &#123;</span><br><span class="line"><span class="comment">//用于标识wr 用户自定义 可以用来传递各种值</span></span><br><span class="line">.wr_id      = wr_id,</span><br><span class="line"><span class="comment">//表示要发送的数据缓冲区 ibv_sge类型指针 为一个数组</span></span><br><span class="line">.sg_list    = &amp;list,</span><br><span class="line"><span class="comment">//指示ibv_sge的数目</span></span><br><span class="line">.num_sge    = <span class="number">1</span>,</span><br><span class="line"><span class="comment">//执行操作的类型，发送带有立即数据的类型</span></span><br><span class="line">.opcode     = IBV_WR_SEND_WITH_IMM,</span><br><span class="line"><span class="comment">//指定发送操作的行为  发送操作完成后会生成一个完成队列条目（CQE）</span></span><br><span class="line">.send_flags = IBV_SEND_SIGNALED,</span><br><span class="line"><span class="comment">//转换为网络字节数据 立即数 其中为32字节数据 用来传递消息</span></span><br><span class="line">.imm_data   = <span class="built_in">htonl</span> (imm_data)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><h3 id="UD"><a href="#UD" class="headerlink" title="UD"></a>UD</h3><p>UD下流程大体相同，但是接收端不会返回ACK。<br>但是需要填入之前交换得到的地址信息 来创建AH 并在发送时传入AH<br>最大的大小就是4KB 由具体设备确定[5]</p><blockquote><p>Modern RDMA compatible NICs supports MTU of size 2KB to 4KB<br>超出大小，设备会自行分片</p></blockquote><ul><li>创建地址信息：需要远程的端口信息</li></ul><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ibv_ah_attr</span> <span class="title">ah_attr</span> =</span> &#123;&#125;;</span><br><span class="line">ah_attr.is_global = <span class="number">1</span>,</span><br><span class="line">ah_attr.dlid = context[<span class="number">1</span>].lid,</span><br><span class="line">ah_attr.port_num = IB_PORT;</span><br><span class="line">ibv_ah *ah0 = ibv_create_ah(context[<span class="number">0</span>].pd, &amp;ah_attr);</span><br></pre></td></tr></table></figure></div><ul><li>发送时填入地址信息，对端的QPN, Qkey（校验所用）</li></ul><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wr.opcode = IBV_WR_SEND;</span><br><span class="line">wr.wr.ud.ah = ah0;</span><br><span class="line">wr.wr.ud.remote_qpn = remoteQPN;</span><br><span class="line">wr.wr.ud.remote_qkey = UD_PKEY;</span><br></pre></td></tr></table></figure></div><p>接收区的大小不能正好等于发送大小, 同时必须使用 a Global Routing Header (GRH) of 40B,消息一般不能低于8B所以最小不小于48B<br>接收大小需要额外增加40B 在接收区的前面部分将会填入GRH,要从40B后开始读</p><blockquote><p>卡我两天的bug</p></blockquote><p>所以要注意两个问题</p><ol><li>接收要比发送至少多40B</li></ol><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rdmaReceive(qp[<span class="number">1</span>], mm[<span class="number">1</span>], <span class="number">128</span>+<span class="number">40</span>, mr[<span class="number">1</span>]-&gt;lkey);</span><br><span class="line">rdmaSend(qp[<span class="number">0</span>], mm[<span class="number">0</span>], <span class="number">128</span>, mr[<span class="number">0</span>]-&gt;lkey, ah[<span class="number">0</span>], qp[<span class="number">1</span>]-&gt;qp_num, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure></div><ol start="2"><li>读取的时候从40B后开始读取</li></ol><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* out1 = (<span class="type">char</span> *)mm[<span class="number">1</span>] + OFFSET;</span><br></pre></td></tr></table></figure></div><h2 id="单边通信"><a href="#单边通信" class="headerlink" title="单边通信"></a>单边通信</h2><p>单边通信需要额外交换的信息包括</p><table><thead><tr><th>type</th><th>meaning</th></tr></thead><tbody><tr><td>address</td><td>uint64_t 允许操作的地址</td></tr><tr><td>rkey</td><td>uint32_t 用于权限保护的key</td></tr></tbody></table><p>单边通信主要是借助远端网卡的DMA直接对内存发起读写，进而绕过了远端CPU，因此也不需要RQ队列。<br>与此同时，在进行单边通信时，需要知晓远端可读写的内存地址（虚拟地址）和remote key(用于安全保护)才能访问远端内存，这部分信息同样是在交换QP信息的时候一并完成。<br>整体通信如下</p><ul><li>请求端发起WR</li><li>请求端网卡拉取WR，根据WR的内容，从内存读数据，组装成RDMA数据包，发送到远端</li><li>响应端收到数据包，解析目的虚拟地址，转换成本地物理地址，解析数据，读写内存数据</li><li>响应端回复数据&#x2F;ACK报文给请求端。</li><li>请求端网卡收到后，生成CQE，放置到CQ中。</li></ul><h3 id="Write"><a href="#Write" class="headerlink" title="Write"></a>Write</h3><p>RDMA write的流程如下<br><img lazyload src="/images/loading.svg" data-src="https://cloudflare-imgbed-4ea.pages.dev/file/Arch/RDMA/1760287004529_hyperloop_RDMA_WRITE.png" alt="hyperloop_RDMA_WRITE.png"></p><ul><li>请求端发起WR</li><li>请求端网卡拉取WR，根据WR的内容，从内存读数据，组装成RDMA数据包，发送到远端</li><li>响应端收到数据包，解析目的虚拟地址，转换成本地物理地址，解析数据，写入RNIC buffer。实际上如下说明，何时写入内存由RNIC决定。</li></ul><blockquote><p>IB Spec. 9.7.5.1.6 ACKNOWLEDGE MESSAGE SCHEDULING原文：”For SEND or RDMA WRITE requests, an ACK may be scheduled before data is actually written into the responder’s memory. The ACK simply indicates that the data has successfully reached the fault domain of the responding node. That is, the data has been received by the channel adapter and the channel adapter will write that data to the memory system of the responding node, or the responding application will at least be informed of the failure.“</p></blockquote><ul><li>响应端回复数据&#x2F;ACK报文给请求端。</li><li>请求端网卡收到后，生成CQE，放置到CQ中。</li></ul><h3 id="write-with-imm"><a href="#write-with-imm" class="headerlink" title="write with imm"></a>write with imm</h3><p>接收端需要post recv才能接收立即数</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sge_list = null //可以为空</span><br><span class="line">num_sge = 0  //</span><br></pre></td></tr></table></figure></div><p>而这个过程同样可以write一并写入<br>立即数需要读取wr请求才能获取</p><blockquote><p>所以需要发一个post recv</p></blockquote><p>比如</p><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接收端 post recv</span></span><br><span class="line">rdmaReceive(qp[<span class="number">1</span>], mm[<span class="number">1</span>], <span class="number">1024</span>, mr[<span class="number">1</span>]-&gt;lkey, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//发送端执行write with imm操作</span></span><br><span class="line">rdmaWrite(qp[<span class="number">0</span>], mm[<span class="number">0</span>], mm[<span class="number">1</span>], <span class="number">20</span>, mr[<span class="number">0</span>]-&gt;lkey, mr[<span class="number">1</span>]-&gt;rkey, <span class="number">1</span>);</span><br><span class="line"><span class="comment">//接收端poll cq</span></span><br><span class="line">pollWithCQ(cq[<span class="number">1</span>], <span class="number">1</span>, &amp;wc);</span><br><span class="line">Debug::notifyInfo(<span class="string">&quot;0-&gt;1 imm写入成功&quot;</span>);</span><br><span class="line"><span class="comment">//从WC中读取立即数</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;recv: %d\n&quot;</span>, wc.imm_data);</span><br></pre></td></tr></table></figure></div><h3 id="Read"><a href="#Read" class="headerlink" title="Read"></a>Read</h3><p><img lazyload src="/images/loading.svg" data-src="https://cloudflare-imgbed-4ea.pages.dev/file/Arch/RDMA/1760287015858_hyperloop_RDMA_READ.png" alt="hyperloop_RDMA_READ.png"></p><ul><li>请求端发起WR</li><li>请求端网卡拉取WR，根据WR的内容，从内存读数据，组装成RDMA数据包，发送到远端</li><li>响应端收到数据包，解析目的虚拟地址，转换成本地物理地址，解析数据，读内存数据</li><li>响应端回复数据给请求端。</li><li>请求端硬件收到数据包，解析提取出数据后放到READ WQE指定的内存区域中</li><li>请求端网卡收到后，生成CQE，放置到CQ中。</li></ul><h3 id="原语"><a href="#原语" class="headerlink" title="原语"></a>原语</h3><p>RDMA协议提供的原语按照原子性的覆盖范围可以分为</p><ul><li>IBV ATOMIC NONE</li><li>IBV ATOMIC HCA</li><li>IBV_ATOMIC_GLOBAL<br>目前只能实现IBV ATOMIC HCA， 意思是atomic只能对网卡生效。在Global范围内，本机内存范围和网卡的原子访问在同一原子性范围内。[1]<br>对于atomic操作 RDMA采用bucket(内部的一个物理锁表实现的)的方式，通过目标地址的后12 bit来定位表项放于同一个bucket，同一个bucket需要等待[4]<blockquote><p>对于地址相隔4KB的RDMA atomic操作，即便目标地址实际不同，但由于其后12 bit相同，它们都被分配到同一个锁表表项争用同一把锁，在此产生争用冲突。</p></blockquote></li></ul><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p>原语都需要指定本地内存地址，用以存放返回的旧值</p><h3 id="FAA"><a href="#FAA" class="headerlink" title="FAA"></a>FAA</h3><p>FAA是从低地址开始+value, 其中value可以通过左移来实现指定位的加减，也可以加上负数来实现增减</p><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>单边通信需要正确的地址，否则会触发内存保护，导致QP进入error state</p><h2 id="原语的性能比较"><a href="#原语的性能比较" class="headerlink" title="原语的性能比较"></a>原语的性能比较</h2><p>峰值吞吐量 Read&lt;Write &lt; Send[3]</p><h2 id="参考-3"><a href="#参考-3" class="headerlink" title="参考"></a>参考</h2><ol><li>原子性范围<br><a class="link" target="_blank" rel="noopener" href="https://sigops.org/s/conferences/sosp/2015/current/2015-Monterey/158-wei-online.pdf">SOSP-15: Fast and General Distributed Transactions using RDMA and HTM<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li><li>和host通信<br><a href="%E8%AE%BA%E6%96%87/Design%20Guidelines%20for%20High%20Performance%20RDMA%20Systems.md">Design Guidelines for High Performance RDMA Systems</a></li><li>原语性能比较<br><a href="%E8%AE%BA%E6%96%87/Understanding%20RDMA%20Microarchitecture%20Resources%20for%20Performance%20Isolation.md">Understanding RDMA Microarchitecture Resources for Performance Isolation</a></li><li>网卡并发控制机制<br><a href="../../%E5%88%86%E7%A6%BB%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E7%BD%91%E7%BB%9C%E4%B8%8E%E5%AD%98%E5%82%A8/disaggregated%20memory/data%20structure/%E8%AE%BA%E6%96%87/Sherman%20%20%20A%20Write-Optimized%20Distributed%20B+Tree%20Index%20on%20Disaggregated%20Memory.md">Sherman A Write-Optimized Distributed B+Tree Index on Disaggregated Memory</a><br><a href="../../../%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%88%86%E7%A6%BB%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E7%BD%91%E7%BB%9C%E4%B8%8E%E5%AD%98%E5%82%A8/disaggregated%20memory/%E5%8D%95%E8%BE%B9%E4%BC%98%E5%8C%96/%E8%AE%BA%E6%96%87/Design%20Guidelines%20for%20Correct,%20Efficient,%20and%20Scalable%20Synchronization%20using%20One-Sided%20RDMA.md">Design Guidelines for Correct, Efficient, and Scalable Synchronization using One-Sided RDMA</a></li><li>use DCT<br><a class="link" target="_blank" rel="noopener" href="https://github.com/jcxue/RDMA-Tutorial/wiki">https://github.com/jcxue/RDMA-Tutorial/wiki<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li></ol><h2 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h2><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>用户调用Verbs接口是线程安全的，框架或者驱动程序会给对应的资源加锁</p><h1 id="RDMA操作高级特性"><a href="#RDMA操作高级特性" class="headerlink" title="RDMA操作高级特性"></a>RDMA操作高级特性</h1><h2 id="Extended-atomic-verbs"><a href="#Extended-atomic-verbs" class="headerlink" title="Extended atomic verbs"></a>Extended atomic verbs</h2><p>由Mallenox提供的扩展特性，但是只能用于其MLNX_OFED环境下，基于其硬件支持，在5.1.6之后不再支持，因为全面融入了rdma-core主线</p><ul><li>包括 wait原语</li></ul><h2 id="Doorbell机制"><a href="#Doorbell机制" class="headerlink" title="Doorbell机制"></a>Doorbell机制</h2><p>在RC模式下，RDMA发送端batch的写操作（write,atmoic）按序发出，接收端也会按序执行。 这里只保证操作的顺序，而不保证整个流程的原子性。毕竟网卡是可以并发执行操作的。</p><h2 id="修改操作类型"><a href="#修改操作类型" class="headerlink" title="修改操作类型"></a>修改操作类型</h2><p>通过修改RDMA header即可实现操作类型的修改[2]</p><h2 id="参考-4"><a href="#参考-4" class="headerlink" title="参考"></a>参考</h2><ol><li>Sherman</li><li>Zero-sided RDMA: Network-driven Data Shuffling for Disaggregated Heterogeneous Cloud DBMSs</li></ol><h1 id="RDMA内存管理"><a href="#RDMA内存管理" class="headerlink" title="RDMA内存管理"></a>RDMA内存管理</h1><p>无论是双边和单边，最后都需要根据WQE读写内存。由于DMA只能通过物理地址访问，所以RNIC保存了一份虚拟地址（VA）到物理地址（PA）的映射表Memory Translation Table(MTT)中, 同时DMA无法感知到page fault，RDMA的操作内存需要提前pin住避免换出，因此需要在RDMA通信完成前同时完成内存注册。<br>RDMA内存注册的过程如下，以IB为例</p><ul><li>获取IB设备context</li><li>通过IB设备context获取PD(Protection domain)</li><li>通过PD注册内存MR</li></ul><h2 id="MR"><a href="#MR" class="headerlink" title="MR"></a>MR</h2><p>memory region(MR)是由RDMA软件层划分出来的内存，在注册时，会在内存创建一个VA to PA的映射表。同时pin住内存，避免换页<br>在ibverbs中具体实现为</p><div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ibv_mr</span> *<span class="built_in">ibv_reg_mr</span>(<span class="keyword">struct</span> ibv_pd *pd, <span class="type">void</span> *addr, <span class="type">size_t</span> length,</span><br><span class="line">              <span class="type">int</span> access);</span><br><span class="line"><span class="comment">// void *addr和length来自通过内存管理(malloc等)申请的内存区域</span></span><br></pre></td></tr></table></figure></div><p><code>access</code>用于指定该内存区域的访问权限，共有四种</p><ul><li>本地写权限（一定有读权限）</li><li>远端读写,原子操作权限<br>注意传入的内存需要对齐<br>其中返回的结构体<code>ibv_mr</code>则会包含权限控制key</li></ul><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ibv_mr</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ibv_context</span>     *<span class="title">context</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ibv_pd</span>	       *<span class="title">pd</span>;</span></span><br><span class="line">	<span class="type">void</span>		       *addr;</span><br><span class="line">	<span class="type">size_t</span>			length;</span><br><span class="line">	<span class="type">uint32_t</span>		handle;</span><br><span class="line">	<span class="comment">// 本地内存区域访问权限</span></span><br><span class="line">	<span class="type">uint32_t</span>		lkey;</span><br><span class="line">	<span class="comment">// 远端内存区域访问权限</span></span><br><span class="line">	<span class="type">uint32_t</span>		rkey;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><p>我们注意到在传入的参数中还有pd, 其含义为</p><h2 id="Protection-Domain"><a href="#Protection-Domain" class="headerlink" title="Protection Domain"></a>Protection Domain</h2><p>问题在于memory region没有和QP建立绑定关系，只要知道了VA和Rkey就可以通过本地某一个QP访问相应的MR，为此PD就是一个绑定QP和MR然后进行分组隔离的概念。根据代码和概念可知QP和MR是不能跨PD的。<br><img lazyload src="/images/loading.svg" data-src="https://cloudflare-imgbed-4ea.pages.dev/file/Arch/RDMA/1760287028734_RDMA%E7%9A%84PD.png" alt="RDMA的PD.png"><br>PD通过划分保护域，PD里面包含QP和MR（没有局限数量），还有AH(address handle)，PD内部的QP可以访问里面的任意MR而无法访问其他PD的MR<br>在ibverbs中PD描述为</p><div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ibv_pd</span> &#123;</span><br><span class="line">	<span class="comment">//代表硬件信息</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ibv_context</span>     *context;</span><br><span class="line">    <span class="type">uint32_t</span>        handle;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><p>申请PD的过程需要通过</p><div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ibv_pd</span> *<span class="built_in">ibv_alloc_pd</span>(<span class="keyword">struct</span> ibv_context *context);</span><br></pre></td></tr></table></figure></div><p>得到PD后就可以参与到内存注册，并且成为MR结构体的属性<br>在实际通信中，通过QP和Rkey（MR）对应的PD做校验</p><h2 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h2><p>RNIC driver读取内核页表复制到RNIC上<br>page table的invalid等等操作也都是由driver控制</p><h1 id="RDMA内存管理高级特性"><a href="#RDMA内存管理高级特性" class="headerlink" title="RDMA内存管理高级特性"></a>RDMA内存管理高级特性</h1><h2 id="memory-window"><a href="#memory-window" class="headerlink" title="memory window"></a>memory window</h2><h2 id="ODP"><a href="#ODP" class="headerlink" title="ODP"></a>ODP</h2><h1 id="RNIC硬件"><a href="#RNIC硬件" class="headerlink" title="RNIC硬件"></a>RNIC硬件</h1><p>RNIC和host的联系如图所示<br><img lazyload src="/images/loading.svg" data-src="https://cloudflare-imgbed-4ea.pages.dev/file/Arch/RDMA/1760287037599_RNIC%E7%BB%84%E4%BB%B6.png" alt="RNIC组件.png"></p><h2 id="PCIe"><a href="#PCIe" class="headerlink" title="PCIe"></a>PCIe</h2><p>RNIC一般通过PCIe与主机相连。以IB设备如果有两个Infinibands ports，就会关联两个PCIe functions。因此可以通过PCIe查看</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lspci | grep Infiniband</span><br><span class="line">b1:00.0 Infiniband controller: Mellanox Technologies MT43244 BlueField-3 integrated ConnectX-7 network controller (rev 01)</span><br><span class="line">b1:00.1 Infiniband controller: Mellanox Technologies MT43244 BlueField-3 integrated ConnectX-7 network controller (rev 01)</span><br></pre></td></tr></table></figure></div><p>和RNIC相比，Bluefield中情况有所不同，bluefield通过PCIe switch 同时挂上了host 和 RNIC，<strong>相当于RNIC走到host需要两段PCIe路径</strong>（因为是off-path smartnic）<br><img lazyload src="/images/loading.svg" data-src="https://cloudflare-imgbed-4ea.pages.dev/file/Arch/RDMA/1760287049040_RNIC.png" alt="RNIC.png"><br><img lazyload src="/images/loading.svg" data-src="https://cloudflare-imgbed-4ea.pages.dev/file/Arch/RDMA/1760287057838_off-path_smartnic.png" alt="off-path_smartnic.png"></p><p>所以对于bluefiled有两个DMA引擎，一个在RNIC一个在DRAM [1]<br>在PCIe传输上 loop traffic 和 超过了embedding 部分的字节会额外消耗PCIe的带宽</p><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p>RNIC的组件包括</p><ul><li>PUs proccess units 处理器单元</li><li>SRAM</li><li>register</li></ul><h3 id="PUs"><a href="#PUs" class="headerlink" title="PUs"></a>PUs</h3><p>复杂的原语会消耗更多的PUs</p><h3 id="存储（SRAM）"><a href="#存储（SRAM）" class="headerlink" title="存储（SRAM）"></a>存储（SRAM）</h3><p><img lazyload src="/images/loading.svg" data-src="https://cloudflare-imgbed-4ea.pages.dev/file/Arch/RDMA/1760287068908_RDMA_NIC_microarchitecture_hardware_details.png" alt="RDMA_NIC_microarchitecture_hardware_details.png"><br>用于缓存RDMA通信过程中的的数据，包含3种cache(由途中可知不是放在一起，而是三种类型的硬件的缓存)</p><ul><li>the memory translation table (MTT) the memory protection table (MPT)</li><li>the Interconnect Context Memory (ICM) cache: QP 状态信息 MR context of CQ<br>为了减少MTT的占用，论文基本都设置了大页来减少表项</li></ul><h3 id="Doorbell-register"><a href="#Doorbell-register" class="headerlink" title="Doorbell register"></a>Doorbell register</h3><p>如下图每个寄存器都关联了相应的QP,其中寄存器会映射到host的内存空间。host通过ring the doorbell触发RNIC的DMA操作 [2]<br><img lazyload src="/images/loading.svg" data-src="https://cloudflare-imgbed-4ea.pages.dev/file/Arch/RDMA/1760287083745_doorbell_register_in_ConnectX6.png" alt="doorbell_register_in_ConnectX6.png"></p><p>其中如上图， The User Access Region (UAR)是PCI地址空间映射，用于能够直接访问设备。UAR的每个page包含用于控制设备操作的寄存器，不同的进程有不同的UARs，彼此之间隔离并且被内核模块保护。<br>其中映射到的设备PCIe地址空间的虚拟地址，被内核模块<code>mlx5_ib.ko</code>管理。<br>用户可以直接写入值到映射的空间来ring doorbell rigister, ring是通过用户态下PCIe直接传输</p><ul><li>offset 0x800 of the UAR pages: Doorbell registers</li><li>(0x800 ∼ 0x9ff) of the UAR page: blue flame (BF) registers<br>对于Recv则不需要Doorbell, 由网卡届时进行检查<br>对于Send而言，写入WQE第一个8 bytes，如果由多个WQE，则使用最后一个[3]</li></ul><p>当使用ibv_post_send时，将会触发MMIO</p><blockquote><p>When calling <code>ibv_post_send</code>, the CPU uses MMIO to write WR to the NIC memory</p></blockquote><p>如果 setting <code>ibv_send_wr.next</code> pointing to the next WR将会使用DMA<br>而跨QP的消息是无法DMA的</p><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>Mellnox自检</p><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo hca_self_test.ofed</span><br></pre></td></tr></table></figure></div><h2 id="参考-5"><a href="#参考-5" class="headerlink" title="参考"></a>参考</h2><ol><li>网卡PCIe路径研究<br><a href="%E8%AE%BA%E6%96%87/Characterizing%20Off-path%20SmartNIC%20for%20Accelerating%20Distributed%20Systems.md">Characterizing Off-path SmartNIC for Accelerating Distributed Systems</a></li><li>网卡硬件研究<br><a href="%E8%AE%BA%E6%96%87/Scaling%20Up%20Memory%20Disaggregated%20Applications%20with%20%20Smart.md">Scaling Up Memory Disaggregated Applications with Smart</a></li><li>UAR说明<br><a class="link" target="_blank" rel="noopener" href="https://insujang.github.io/assets/pdf/hyperloop_report.pdf">https://insujang.github.io/assets/pdf/hyperloop_report.pdf<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li></ol><h1 id="RDMA-高级特性"><a href="#RDMA-高级特性" class="headerlink" title="RDMA 高级特性"></a>RDMA 高级特性</h1><h2 id="其它外围设备"><a href="#其它外围设备" class="headerlink" title="其它外围设备"></a>其它外围设备</h2><p>只要能通过PCIe bar register 暴露出内存，同时注册给RDMA就可以实现 PCIe device连接上RDMA</p><p>通过libibverbs lib的PeerDirect[1]</p><ol><li>Zero-sided RDMA: Network-driven Data Shuffling for Disaggregated Heterogeneous Cloud DBMSs</li></ol><h1 id="重要"><a href="#重要" class="headerlink" title="重要"></a>重要</h1><h2 id="slow-path-和-fast-path"><a href="#slow-path-和-fast-path" class="headerlink" title="slow path 和 fast path"></a>slow path 和 fast path</h2><ol><li><a class="link" target="_blank" rel="noopener" href="https://www.snia.org/sites/default/files/ESF/Everything-You-Wanted-to-Know-About-RDMA-But-Were-Too-Proud-to-Ask.pdf?utm_source=chatgpt.com">https://www.snia.org/sites/default/files/ESF/Everything-You-Wanted-to-Know-About-RDMA-But-Were-Too-Proud-to-Ask.pdf?utm_source=chatgpt.com<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li><li><a class="link" target="_blank" rel="noopener" href="https://www.snia.org/educational-library">https://www.snia.org/educational-library<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li></ol><h1 id="参考-6"><a href="#参考-6" class="headerlink" title="参考"></a>参考</h1><ol><li>savir的知乎专栏<br><a class="link" target="_blank" rel="noopener" href="https://www.zhihu.com/people/saviour-li">https://www.zhihu.com/people/saviour-li<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li></ol></div><div class="post-copyright-info w-full my-8 px-2 sm:px-6 md:px-8"><div class="article-copyright-info-container"><ul><li><strong>Title:</strong> RDMA概览</li><li><strong>Author:</strong> zyu</li><li><strong>Created at :</strong> 2025-01-30 00:00:00</li><li><strong>Updated at :</strong> 2025-10-12 17:00:10</li><li><strong>Link:</strong> https://codezyu.github.io/2025/01/30/Arch/Net/RDMA Tech Report/</li><li><strong>License: </strong>This work is licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a>.</li></ul></div></div><ul class="post-tags-box text-lg mt-1.5 flex-wrap justify-center flex md:hidden"><li class="tag-item mx-0.5"><a href="/tags/Tech/">#Tech</a>&nbsp;</li><li class="tag-item mx-0.5"><a href="/tags/achitechture/">#achitechture</a>&nbsp;</li><li class="tag-item mx-0.5"><a href="/tags/RDMA/">#RDMA</a>&nbsp;</li></ul><div class="article-nav my-8 flex justify-between items-center px-2 sm:px-6 md:px-8"><div class="article-prev border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2"><a class="prev" rel="prev" href="/2025/07/06/life/%E6%88%91%E6%9C%80%E5%96%9C%E6%AC%A2%E7%9A%84%E4%B9%A6%E5%BA%97/"><span class="left arrow-icon flex justify-center items-center"><i class="fa-solid fa-chevron-left"></i> </span><span class="title flex justify-center items-center"><span class="post-nav-title-item truncate max-w-48">我最喜欢的书店</span> <span class="post-nav-item">Prev posts</span></span></a></div></div><div class="comment-container px-2 sm:px-6 md:px-8 pb-8"><div class="comments-container mt-10 w-full"><div id="comment-anchor" class="w-full h-2.5"></div><div class="comment-area-title w-full my-1.5 md:my-2.5 text-xl md:text-3xl font-bold">Comments</div><div id="waline"></div><script type="module" data-swup-reload-script>import{init}from"/js/libs/waline.js";function loadWaline(){init({el:"#waline",serverURL:"https://example.example.com",dark:'body[class~="dark-mode"]',reaction:!1,requiredMeta:["nick","mail"],emoji:[],lang:"zh-CN"})}"undefined"!=typeof swup?loadWaline():window.addEventListener("DOMContentLoaded",loadWaline)</script></div></div></div><div class="toc-content-container"><div class="post-toc-wrap"><div class="post-toc"><div class="toc-title">On this page</div><div class="page-title">RDMA概览</div><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#RDMA%E4%BB%8B%E7%BB%8D"><span class="nav-text">RDMA介绍</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#RDMA%E8%BD%AF%E4%BB%B6%E6%A0%88"><span class="nav-text">RDMA软件栈</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97"><span class="nav-text">内核模块</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E6%A8%A1%E5%9D%97"><span class="nav-text">用户模块</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#libibverbs"><span class="nav-text">libibverbs</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#libmlx5"><span class="nav-text">libmlx5</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#RDMA%E9%80%9A%E4%BF%A1%E7%AE%80%E6%98%93%E6%B5%81%E7%A8%8B"><span class="nav-text">RDMA通信简易流程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#device-context"><span class="nav-text">device context</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%A8%E5%86%8C%E5%86%85%E5%AD%98"><span class="nav-text">注册内存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#QP"><span class="nav-text">QP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%A1%E6%81%AF%E4%BA%A4%E6%8D%A2"><span class="nav-text">信息交换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#QP%E9%98%9F%E5%88%97%E7%8A%B6%E6%80%81%E5%88%87%E6%8D%A2"><span class="nav-text">QP队列状态切换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RDMA%E6%93%8D%E4%BD%9C"><span class="nav-text">RDMA操作</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#RDMA%E6%9C%8D%E5%8A%A1%E7%B1%BB%E5%9E%8B"><span class="nav-text">RDMA服务类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#QP%E9%98%9F%E5%88%97"><span class="nav-text">QP队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#SQ%E5%92%8CRQ"><span class="nav-text">SQ和RQ</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CQ"><span class="nav-text">CQ</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SRQ"><span class="nav-text">SRQ</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E9%9D%A0"><span class="nav-text">可靠</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="nav-text">实现原理：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PSN"><span class="nav-text">PSN</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5"><span class="nav-text">连接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%94%AF%E6%8C%81%E6%93%8D%E4%BD%9C"><span class="nav-text">支持操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83"><span class="nav-text">参考</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#RDMA%E5%8D%8F%E8%AE%AE"><span class="nav-text">RDMA协议</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#RDMA%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84"><span class="nav-text">RDMA网络结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ROCE"><span class="nav-text">ROCE</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#iWARP"><span class="nav-text">iWARP</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%BB%E5%9D%80"><span class="nav-text">寻址</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#GID"><span class="nav-text">GID</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LID"><span class="nav-text">LID</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#address-handle"><span class="nav-text">address handle</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83-1"><span class="nav-text">参考</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#RDMA%E9%80%9A%E4%BF%A1"><span class="nav-text">RDMA通信</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#QP%E7%8A%B6%E6%80%81%E6%9C%BA"><span class="nav-text">QP状态机</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#INIT"><span class="nav-text">INIT</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RTR"><span class="nav-text">RTR</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RTS"><span class="nav-text">RTS</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#RDMA%E9%80%9A%E4%BF%A1%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7"><span class="nav-text">RDMA通信高级特性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#RDMA-DCT"><span class="nav-text">RDMA DCT</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#key-object"><span class="nav-text">key object</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DCI"><span class="nav-text">DCI</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DCT"><span class="nav-text">DCT</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%B9%E6%80%A7"><span class="nav-text">特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DCT-ODP%E7%89%B9%E6%80%A7"><span class="nav-text">DCT ODP特性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#QoS"><span class="nav-text">QoS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83-2"><span class="nav-text">参考</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#RDMA%E6%93%8D%E4%BD%9C-1"><span class="nav-text">RDMA操作</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#workflow"><span class="nav-text">workflow</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#control"><span class="nav-text">control</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#data"><span class="nav-text">data</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E7%B2%92%E5%BA%A6"><span class="nav-text">读写粒度</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Host%E5%92%8CRNIC%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="nav-text">Host和RNIC的通信</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#QP%E4%BF%A1%E6%81%AF%E4%BA%A4%E6%8D%A2"><span class="nav-text">QP信息交换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#connenct-%E8%BF%9E%E6%8E%A5"><span class="nav-text">connenct(连接)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#datagram"><span class="nav-text">datagram</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8C%E8%BE%B9%E9%80%9A%E4%BF%A1"><span class="nav-text">双边通信</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RC-UC%E6%A8%A1%E5%BC%8F%E4%B8%8B"><span class="nav-text">RC&#x2F;UC模式下</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#WR"><span class="nav-text">WR</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E6%94%B6WR"><span class="nav-text">接收WR</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%91%E8%B5%B7WR"><span class="nav-text">发起WR</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#UD"><span class="nav-text">UD</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%95%E8%BE%B9%E9%80%9A%E4%BF%A1"><span class="nav-text">单边通信</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Write"><span class="nav-text">Write</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#write-with-imm"><span class="nav-text">write with imm</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Read"><span class="nav-text">Read</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E8%AF%AD"><span class="nav-text">原语</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CAS"><span class="nav-text">CAS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FAA"><span class="nav-text">FAA</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="nav-text">错误处理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E8%AF%AD%E7%9A%84%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83"><span class="nav-text">原语的性能比较</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83-3"><span class="nav-text">参考</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7"><span class="nav-text">高级特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="nav-text">线程安全</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#RDMA%E6%93%8D%E4%BD%9C%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7"><span class="nav-text">RDMA操作高级特性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Extended-atomic-verbs"><span class="nav-text">Extended atomic verbs</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Doorbell%E6%9C%BA%E5%88%B6"><span class="nav-text">Doorbell机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9%E6%93%8D%E4%BD%9C%E7%B1%BB%E5%9E%8B"><span class="nav-text">修改操作类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83-4"><span class="nav-text">参考</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#RDMA%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-text">RDMA内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#MR"><span class="nav-text">MR</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Protection-Domain"><span class="nav-text">Protection Domain</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A1%B5%E8%A1%A8"><span class="nav-text">页表</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#RDMA%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7"><span class="nav-text">RDMA内存管理高级特性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#memory-window"><span class="nav-text">memory window</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ODP"><span class="nav-text">ODP</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#RNIC%E7%A1%AC%E4%BB%B6"><span class="nav-text">RNIC硬件</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#PCIe"><span class="nav-text">PCIe</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%84%E4%BB%B6"><span class="nav-text">组件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#PUs"><span class="nav-text">PUs</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%EF%BC%88SRAM%EF%BC%89"><span class="nav-text">存储（SRAM）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Doorbell-register"><span class="nav-text">Doorbell register</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4"><span class="nav-text">命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83-5"><span class="nav-text">参考</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#RDMA-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7"><span class="nav-text">RDMA 高级特性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B6%E5%AE%83%E5%A4%96%E5%9B%B4%E8%AE%BE%E5%A4%87"><span class="nav-text">其它外围设备</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%87%8D%E8%A6%81"><span class="nav-text">重要</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#slow-path-%E5%92%8C-fast-path"><span class="nav-text">slow path 和 fast path</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83-6"><span class="nav-text">参考</span></a></li></ol></div></div></div></div></div></div><div class="main-content-footer"><footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color"><div class="info-container py-3 text-center"><div class="text-center">&copy; <span>2022</span> - 2025&nbsp;&nbsp;<i class="fa-solid fa-heart fa-beat" style="--fa-animation-duration:0.5s;color:#f54545"></i>&nbsp;&nbsp;<a href="/">zyu</a><p class="post-count space-x-0.5"><span>7 posts in total</span></p></div><script data-swup-reload-script src="https://cn.vercount.one/js"></script><div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right"><span id="busuanzi_container_site_uv" class="lg:!block"><span class="text-sm">VISITOR COUNT</span> <span id="busuanzi_value_site_uv"></span> </span><span id="busuanzi_container_site_pv" class="lg:!block"><span class="text-sm">TOTAL PAGE VIEWS</span> <span id="busuanzi_value_site_pv"></span></span></div><div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left"><span class="lg:block text-sm">POWERED BY <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a></span> <span class="text-sm lg:block">THEME&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.8.5</a></span></div><div>Blog up for <span class="odometer" id="runtime_days"></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec</div><script data-swup-reload-script>try{function odometer_init(){document.querySelectorAll(".odometer").forEach(e=>{new Odometer({el:e,format:"( ddd).dd",duration:200})})}odometer_init()}catch(e){}</script></div></footer></div></div><div class="post-tools"><div class="post-tools-container"><ul class="article-tools-list"><li class="right-bottom-tools page-aside-toggle"><i class="fa-regular fa-outdent"></i></li><li class="go-comment"><i class="fa-regular fa-comments"></i></li></ul></div></div><div class="right-side-tools-container"><div class="side-tools-container"><ul class="hidden-tools-list"><li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center"><i class="fa-regular fa-magnifying-glass-plus"></i></li><li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center"><i class="fa-regular fa-magnifying-glass-minus"></i></li><li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center"><i class="fa-regular fa-moon"></i></li><li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center"><i class="fa-regular fa-arrow-down"></i></li></ul><ul class="visible-tools-list"><li class="right-bottom-tools toggle-tools-list flex justify-center items-center"><i class="fa-regular fa-cog fa-spin"></i></li><li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center"><i class="arrow-up fas fa-arrow-up"></i> <span class="percent"></span></li></ul></div></div><div class="image-viewer-container"><img src=""></div><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-input-field-pre"><i class="fa-solid fa-keyboard"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="Search..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa-solid fa-times"></i></span></div><div id="search-result"><div id="no-result"><i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i></div></div></div></div></main><script src="/js/build/libs/Swup.min.js"></script><script src="/js/build/libs/SwupSlideTheme.min.js"></script><script src="/js/build/libs/SwupScriptsPlugin.min.js"></script><script src="/js/build/libs/SwupProgressPlugin.min.js"></script><script src="/js/build/libs/SwupScrollPlugin.min.js"></script><script src="/js/build/libs/SwupPreloadPlugin.min.js"></script><script>const swup=new Swup({plugins:[new SwupScriptsPlugin({optin:!0}),new SwupProgressPlugin,new SwupScrollPlugin({offset:80}),new SwupSlideTheme({mainElement:".main-content-body"}),new SwupPreloadPlugin],containers:["#swup"]})</script><script src="/js/build/tools/imageViewer.js" type="module"></script><script src="/js/build/utils.js" type="module"></script><script src="/js/build/main.js" type="module"></script><script src="/js/build/layouts/navbarShrink.js" type="module"></script><script src="/js/build/tools/scrollTopBottom.js" type="module"></script><script src="/js/build/tools/lightDarkSwitch.js" type="module"></script><script src="/js/build/layouts/categoryList.js" type="module"></script><script src="/js/build/tools/localSearch.js" type="module"></script><script src="/js/build/tools/codeBlock.js" type="module"></script><script src="/js/build/layouts/lazyload.js" type="module"></script><script src="/js/build/tools/runtime.js"></script><script src="/js/build/libs/odometer.min.js"></script><link rel="stylesheet" href="/assets/odometer-theme-minimal.css"><script src="/js/build/libs/Typed.min.js"></script><script src="/js/build/plugins/typed.js" type="module"></script><script src="/js/build/libs/mermaid.min.js"></script><script src="/js/build/plugins/mermaid.js"></script><script src="/js/build/libs/anime.min.js"></script><script src="/js/build/tools/tocToggle.js" type="module" data-swup-reload-script=""></script><script src="/js/build/layouts/toc.js" type="module" data-swup-reload-script=""></script><script src="/js/build/plugins/tabs.js" type="module" data-swup-reload-script=""></script><script src="/js/build/libs/moment-with-locales.min.js" data-swup-reload-script=""></script><script src="/js/build/layouts/essays.js" type="module" data-swup-reload-script=""></script><div id="aplayer"></div><script src="/js/build/libs/APlayer.min.js"></script><script src="/js/build/plugins/aplayer.js"></script></body></html>