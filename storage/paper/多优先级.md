### 一、 核心理论与经典论文 (The Classics)

这一领域的基石主要来自于操作系统对实时性的要求，随后被引入数据库并发控制。

#### 1. 锁的优先级反转与继承

这是所有优先级锁研究的起点。如果高优先级任务被低优先级任务持有的锁阻塞，而中优先级任务又抢占了低优先级任务，就会导致高优先级任务无限期等待（火星探路者号故障的根源）。

- **经典论文:** **"Priority Inheritance Protocols: An Approach to Real-Time Synchronization" (Sha, Rajkumar, Lehoczky, IEEE TC 1990)**
    
    - **核心贡献:** 提出了 **优先级继承协议 (PIP)** 和 **优先级天花板协议 (PCP)**。
        
    - **机制:** 当高优先级线程等待锁时，持有锁的低优先级线程临时继承高优先级，从而加速锁的释放。
        
    - **C++ 实践:** 在 Linux C++ 中，`pthread_mutex` 可以通过 `PTHREAD_PRIO_INHERIT` 属性开启此功能。
        

#### 2. 数据库中的优先级并发控制

在数据库中，优先级不仅仅是 CPU 调度，更涉及事务的回滚策略（谁让路）。

- **经典论文:** **"System R: A Relational Approach to Database Management" (及其后续关于 Two-Phase Locking 的研究)**
    
    - 虽然是基础，但引出了 **Wound-Wait** 和 **Wait-Die** 机制（Rosenkrantz et al., 1978）。
        
    - **Wound-Wait (抢占式):** 高优先级事务请求锁，持有锁的低优先级事务被“杀掉”（回滚）。
        
    - **Wait-Die (非抢占式):** 高优先级事务请求锁，如果被低优先级持有，高优先级等待；反之则低优先级自杀。这是分布式数据库（如 Google Spanner）常用的死锁避免兼优先级机制。
        
- **实时数据库论文:** **"Scheduling Real-Time Transactions: A Performance Evaluation" (Abbott & Garcia-Molina, VLDB 1988/1992)**
    
    - 详细评估了在数据库中如何将“截止时间（Deadline）”映射为锁的优先级。
        

---

### 二、 现代高性能系统论文 (Modern & Performance-Oriented)

在现代多核和 NUMA 架构下，简单的优先级继承开销太大（涉及内核上下文切换）。现代研究更关注用户态锁和减少竞争。

#### 1. 感知竞争的锁调度

- **论文:** **"Contention-Aware Lock Scheduling for Transactional Databases" (Tian et al., VLDB 2018)**
    
    - **痛点:** 传统的 FIFO 锁在高竞争下会导致“护送效应”（Convoy Effect）。
        
    - **创新:** 提出不仅仅基于 FIFO，而是根据事务的“竞争程度”或“优先级”来决定把锁给谁。即在锁的等待队列中进行重排序（Reordering），让最可能快速提交的事务先拿到锁，从而提高整体吞吐量。
        
    - **关联技术:** **MCS Locks with Priority**（基于队列的自旋锁的变种）。
        

#### 2. 针对 OLTP 的抢占优化

- **论文:** **"Improving preemptive prioritization via statistical characterization of OLTP locking" (2010)**
    
    - **核心:** 分析了为什么标准的优先级继承在 TPC-C（在线交易处理）负载下表现不佳，并提出了一种基于统计特性的抢占策略（POW），在不牺牲低优先级吞吐量的前提下保护高优先级事务。
        

---

### 三、 基于优先级的日志 (Priority-based Logging/WAL)

“优先级日志”比“优先级锁”更难实现，因为 **Write-Ahead Log (WAL)** 必须严格保序以确保原子性和可恢复性（ARIES 协议要求）。你不能随意跳过低优先级事务的日志去写高优先级的，否则崩溃恢复时数据会损坏。

目前的“优先级日志”主要体现在 **I/O 调度** 和 **Group Commit** 层面：

#### 1. 优先级感知的组提交 (Priority Group Commit)

- **概念:** 在进行 `fsync` 或 `fdatasync` 时，如果一个 Batch 中包含高优先级事务，系统可能会提前触发刷盘，或者在内存中的 Log Buffer 里，优先将高优先级事务的记录打包。
    
- **相关研究:** **"On the Performance of Priority-Based logging in Real-Time Databases"** (学术界较早期的探讨)。
    
- **现代实践:** 现在的 NVRAM（非易失性内存）日志研究更多。例如使用 SPDK/RDMA 直接写入远程持久内存，高优先级线程拥有独立的 RDMA 通道或 Log Buffer 区域。
    

#### 2. 存储层面的优先级 (Priority I/O)

- **论文:** **"Priority-aware Log Collection Method for Storage Systems" (2024)**
    
    - 注意：这篇主要讲的是_诊断日志_而非_事务日志_。
        
- **实际系统:** 在 Linux 中，使用 `ioprio_set` (I/O Priority) 让处理高优先级事务的写线程（Writer Thread）获得更高的磁盘调度权重。