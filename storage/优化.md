# CPU乱序
CPU会预读一个指令窗口（比如几十上百条指令），然后找出其中**没有数据依赖关系**的指令。当一个指令因为等待内存而卡住（Stall）时，CPU不会傻等，而是会去执行后面其他不相关的、已经准备就绪的指令，从而让自己的计算单元保持忙碌。
我们可以利用这种优化，**比如查询链表**
- 链表天然无法利用预取
对于单链表是无法做到优化的，但是对于多链表我们有两种查询方法
```cpp
// func1
for(链表 L : 链表集合){
	// 遍历每个链表直到找到
}
// func2
for(all_find){
	for(链表 L : 链表集合){
		// 每个链表推一步
	}
}
```
显然对于func2的性能会更强，因为可以利用CPU乱序执行实现多链表的并行（哪怕你是单线程）
